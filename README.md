# **Galpy**

<br>

<p align="center">
  <img width=300 src="https://github.com/CheckGalpy/galpy-client/blob/develop/assets/images/logo.png" />
</p>

<br>

Galpy는 간단한 촬영으로 **책갈피**를 생성하고 관리할 수 있게 해주는 모바일 어플리케이션입니다.

**팔로잉** 기능을 통해 자신의 책갈피를 공유하거나 관심 계정의 책갈피를 열람할 수 있으며, **추천 알고리즘**을 통해 유사한 관심사를 가진 사용자의 책갈피를 추천 받고, 취향에 맞는 책갈피를 **즐겨찾기**에 추가할 수 있습니다.

> [Galpy 시연 영상](https://youtu.be/cUFZ1A8MCoU?t=5132) 

> [서버 레포지토리](https://github.com/CheckGalpy/galpy-server)

<br>

# Table of Contents

- [Preview](#preview)
- [Motivation](#motivation)
- [Challenges](#challenges)
  - [1. 촬영으로 책갈피 생성하기](#1-촬영으로-책갈피-하기)
    - [지저분하게 추출된 텍스트, 간편하게 가공할 순 없을까?](#지저분하게-추출된-텍스트-간편하게-가공할-순-없을까)
    - [연사모드: 여러 이미지를 묶어 하나의 책갈피를 생성하기](#연사모드-여러-이미지를-묶어-하나의-책갈피를-생성하기)
  - [2. 추천 알고리즘](#2-추천-알고리즘)
    - [책갈피 추천은 어떤 근거로 이루어질까?](#책갈피-추천은-어떤-근거로-이루어질까)
    - [관심사 유사도 계산하기](#관심사-유사도-계산하기)
  - [3. 로딩시간 단축하기](#2-로딩시간-단축하기)
    - [사전연산을 통해 로딩속도 개선하기](#사전연산을-통해-로딩속도-개선하기)
  - [4. 편의성과 보안](#4-편의성과-보안)
    - [리액트 네이티브에서 토큰과 스토리지 사용하기](#리액트-네이티브에서-토큰과-스토리지-사용하기)
- [UX 개선하기](#UX-개선하기)
    - [1. 검색 경험 개선하기](#1-검색-경험-개선하기)
      - [검색 키워드 하이라이팅](#검색-키워드-하이라이팅)
      - [키워드 매칭하기](#키워드-매칭하기)
    - [2. 목록 열람 경험 개선하기](#2-목록-열람-경험-개선하기)
      - [효율적인 썸네일 구조 제작](#효율적인-썸네일-구조-제작)
      - [삭제하기와 팔로잉 인터랙션의 차이](#삭제하기와-팔로잉-인터랙션의-차이)
- [Tech stack](#tech-stack)
- [Timeline](#timeline)
- [Remarks](#remarks)

<br>

# Preview

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/5051b956-dfbe-45d9-9206-37f5805a5d13" align="center" width="19%">&nbsp;
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/44b18e62-ed3a-4741-beef-a6f7ba291e90" align="center" width="19%">&nbsp;
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/f5b2d654-8c5d-44da-a1e6-d35e8c5fc8c4" align="center" width="19%">&nbsp;
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/0bdf91a8-a0e9-4a3c-a607-c4b66466b493" align="center" width="19%">&nbsp;
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/8e246ab2-b809-4128-a088-38ababb2c4a2" align="center" width="19%">
</p>

<details>
  
  <summary>기능 목록</summary>
  
  ### 대시보드 스크린
  1. 책갈피 추천
  2. 해시태그, 팔로잉, 즐겨찾기 정보 현황 디스플레이
  
  ### 책갈피 스크린
  1. 나의 책갈피 디스플레이
  2. 수집된 책갈피 디스플레이 <br> 
  3. 책갈피 검색/하이라이팅 <br> 
  4. 책갈피 정렬 <br> 
  5. 책갈피/해시태그 편집/삭제 <br> 
  6. 책갈피 오토포매팅</td>
  
  ### 갈피추가 스크린
  1.책갈피 생성 <br> 
  2. 책갈피 연사촬영</td>

  ### 팔로잉 스크린
  1. 팔로잉 목록 디스플레이 <br> 
  2. 친구 찾기 <br> 
  3. 팔로잉 목록 검색 <br> 
  4. 팔로잉 목록 정렬 <br> 
  5. 팔로우/언팔로우</td>

  ### 설정 스크린
  1. 로그아웃
  
</details>

<br>

# Motivation

책을 읽다가 인상깊은 글귀를 발견했을 때면 드는, '**이 책갈피는 저장해 두었다가 나중에 다시 읽고 싶다'**'라는 생각에서 Galpy는 출발하게 되었습니다.

처음에는 해당 글귀의 위치를 표시하기 위해 책 페이지의 모서리를 접거나 본문에 밑줄을 긋는 등의 방법을 사용하였습니다. 하지만 책 원본이 훼손된다는 단점이 있었고, 이를 극복하기 위한 방법으로 처음엔 메모앱/노션등의 기록도구로 저장하고자 하는 글귀를 일일이 타이핑치고 분류해 왔습니다. 하지만 책을 읽을 때마다 항상 컴퓨터가 필요하다는 점과, 기록과 읽기를 병행해야 한다는 점은 여전히 큰 불편함으로 다가왔습니다.

<p align="center">
    <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/941d7bd4-bbc9-4abd-81aa-583d85796f0f">
</p>

<div align="center">
  <sub><기존에 책갈피를 저장하던 방법></sub>
</div>
  
<br>

<br>

이에 원본을 훼손하거나 일일이 기록하지 않아도 글귀를 저장할 수 있으며, 검색기능이 있어 연관된 주제의 책갈피들을 편리하게 열람할 수 있는 서비스가 있으면 좋겠다는 스스로의 니즈가 있었습니다. 그리고 이러한 니즈를 충족시키기 위해서는 카메라로 글귀를 촬영하여 텍스트를 추출하고, 추출된 텍스트를 책갈피의 형태로 생성하여 관리해주는 서비스가 필요하다고 판단하였습니다. 그렇게 OCR (광학문자열인식) API를 이용한 모바일 어플리케이션, Galpy를 기획하고 개발하게 되었습니다.

<br>

# Challenges

## 1. 촬영으로 책갈피 생성하기

### 지저분하게 추출된 텍스트, 간편하게 가공할 순 없을까?

먼저, 사용자가 간편하게 책갈피를 생성할 수 있도록 `React Native`와 `Google Vision API`를 이용하여 촬영된 책의 이미지에서 텍스트를 추출하는 기능을 구현할 수 있었습니다. `OCR API`의 한국어 텍스트 인식률이 높지 않을 수 있겠다라는 우려와 달리, 추출된 문자열의 정확도는 준수했습니다. 

하지만 촬영되는 책 페이지의 레이아웃은 각각 다르고, 포함되어진 문장간의 줄바꿈이 일관되지 않다는 문제점이 있었습니다. 책갈피를 생성하기 위해선 추출된 텍스트를 **가독성 좋은 블록 형태**로 저장해야 하는데, 이를 위해선 사용자가 일일이 줄을 오가며 **줄바꿈**을 되돌려야 한다는 불편함이 있었습니다.

<p align="center">
    <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/e5c07d94-59b9-43a0-8776-2c3e7698c936">
</p>

<div align="center">
  <sub><일관되지 못한 줄바꿈으로 인해 가독성이 해쳐진 모습></sub>
</div>
  
<br>

<br>

위의 문제를 해결하기 위해 `정규표현식`을 사용하여 추출된 텍스트 덩어리를 분리하고, 줄바꿈을 제거한 뒤 다시 연결할 수 있는 기능을 구현하였습니다. 해당기능을 트리거하는 방법은 다음과 같이 크게 3가지가 있었습니다:
|-| 자동 포매팅 | 버튼 터치시 동작 | 터치 모션 감지 |
|---|---|---|---|
| 장점 | 간편 | 상황에 따라 포맷팅 유무 선택가능 | 상황에 따라 포맷팅 유무 선택불가 <br> 모바일 기기만의 특성 적용가능 |
| 단점 | 포매팅 선택권 없음 | UI의 복잡도 상승| - |
  
<br>

매 촬영마다 해당기능이 자동으로 활성화되는 `자동 포매팅`의 경우, 간편하지만 상황에 따라 사용자가 포맷팅을 원치 않을 수 있다고 판단하였습니다. 버튼을 추가하는 경우 사용자에게 선택권을 줄 수 있다는 장점이 있지만, UI가 복잡해지며 UX를 해칠 확률이 높아질 것이라고 생각하였습니다. 이에 사용자에게 선택권을 부여하면서도 별도의 UI컴포넌트의 추가를 필요로 하지 않는 터치 모션을 사용하여 포맷팅 기능을 트리거 하기로 결정하였습니다.
  
다양한 터치 모션중에서, 텍스트열을 압축시키는 듯한 모습과 가장 유사한 제스쳐인 `핀치모션`의 감지를 통해 '**두 손가락을 오므리면 줄바꿈을 제거해주는 기능**'을 최종적으로 구현하기로 결정하였습니다. 또한 사용자의 핀치모션을 감지하기 위해서 `react-native-gesture-handler` 라이브러리의 `PinchGestureHandler` 컴포넌트를 사용하였으며, 실수로 포매팅이 되는 것을 방지하면서도 모션의 인식이 용이한 범위의 감도를 설정하였습니다.

<p align="center">
    <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/a5e4f56a-3cd1-4532-b875-d5cd0cc8fd07">
</p>
  
<div align="center">
  <sub><핀치모션으로 포매팅을 적용하는 모습></sub>
</div>

<br>

### 연사모드: 여러 이미지를 묶어 하나의 책갈피를 생성하기

책갈피를 생성하며 유저가 겪는 또다른 어려움은, 촬영하고 싶은 글귀가 책의 좌우 **두 페이지에 걸쳐**있을 때 발생 하였습니다. 기존의 기능만으로는 분단된 글귀를 각각 별개의 책갈피로 생성하거나, 하나의 글귀만 촬영하여 나머지 텍스트를 직접 추가해야 하는 불편함이 있었습니다. 

<p align="center">
    <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/69c4c876-b340-4266-965e-b0a6cb29160e7">
</p>

<div align="center">
  <sub><타겟 문자열의 분단 케이스 예시></sub>
</div>
  
<br>
  
이러한 사용자의 불편함을 해결하기 위해, 촬영을 여러번 진행하더라도 각 이미지에서 추출된 텍스트를 **하나의 덩어리로 연결**하여 책갈피를 생성할 수 있는 기능인 `연속스캔` 기능의 개발이 필요하다고 판단하였습니다. 기존 방식에서는 추출한 텍스트를 상태에 저장하여 관리하였는데, 해당 상태는 Scan.js 하나의 컴포넌트에서만 사용되었기 때문에 useState를 통해 로컬에서 관리하였습니다.
  
| Screen Name | Scan.js | ScanEdit.js | BookmarkDetail.js |
|---|---|---|---|
| 화면 예시 |<img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/e4b0db5f-6171-4f87-8ff1-3db559f63422">|<img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/7695eb71-cfa3-420d-a03e-f07d778e1259">|<img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/3988d42a-c805-498f-9335-fe4671b5eb9e">|
| 상태 | N/A | 추출 텍스트를 `local state`에 저장 | N/A |

<div align="center">
  <sub><연속스캔기능 추가 전 useEffect를 이용한 상태관리 플로우></sub>
</div>
  
<br>
  
<br>
  
`연속스캔` 기능을 구현하기 위해서는, `ScanEdit.js`가 렌더링된 화면에서 촬영을 진행한 후, 이미지에서 텍스트를 추출하여 상태에 저장하고, 다시 `Scan.js`가 렌더링된 하면으로 이동하여 텍스트를 추출하는 과정을 반복해야 했습니다. 그리고 이 과정에서 새롭게 추출된 텍스트는, 이전의 상태에 저장되어 있던 텍스트에 합쳐서 저장되어야 했습니다.
  
`navigation`의 스크린을 이동하며 화면이 다시 렌더링이 진행되어도 상태를 보존해야 하는 필요성이 생김에 따라, 기존 `useState`를 통해 로컬에서 관리되던 상태를 `redux`를 통해 전역에서 관리하는 방법으로 변경하기로 결정하였습니다.

  
<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/8cf05109-e11b-40fb-98c1-99d9e3f3e49b">
</p>
  
<div align="center">
  <sub><연속스캔기능 추가 후 redux를 이용한 상태관리 플로우></sub>
</div>

<br>

## 2. 추천 알고리즘

### 책갈피 추천은 어떤 근거로 이루어질까?
  
본 서비스가 사용자에게 제공하는 가치는 크게 2가지로 구분되어집니다.
  
  1. 사용자가 읽은 책을 책갈피로 생성하여 손쉽게 관리
  2. 사용자가 생성하지 않은 타인의 책갈피를 수집
  
사용자는 자신이 읽은 책의 페이지를 책갈피로 생성하여 관리하는 것 외에도, 타 유저의 계정을 검색하고 `팔로우`함으로서 해당 계정의 책갈피를 열람하고 수집할 수 있습니다. 사용자가 직접 생성한 책갈피 외에도 취향에 맞는 책갈피를 탐색하고 저장하는 기능을 제공하기 위해선, 지인의 계정을 검색할 수 있는 `친구찾기` 기능 외에도 사용자의 취향을 분석하여 비슷한 관심사를 가진 계정과 책갈피를 **추천하는 기능**이 필요했습니다. 

추천기능을 구현하기 위해 사용자가 책갈피를 생성할 때 추가한 해시태그 데이터를 수합하고 분석하여 사용자간의 **관심사 유사도를 수치화**할 수 있었습니다.
  
<br>

유사도를 비교하는데 주로 사용되는 방법은 크게 3가지로 나뉩니다.

##### 1. 코사인 유사도

코사인 유사도는 문장 내의 단어들이 얼마나 유사한 방향을 가리키는지 측정합니다. 이 방법에서는 각 문장을 벡터로 표현하고, 두 벡터 간의 각도를 기반으로 유사도를 계산합니다. 

<p align="center">
  <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2a8c50526e2cc7aa837477be87eff1ea703f9dec" align="center" width="40%">&nbsp;
  <img src="https://wikidocs.net/images/page/24603/%EC%BD%94%EC%82%AC%EC%9D%B8%EC%9C%A0%EC%82%AC%EB%8F%84.PNG" align="center" width="40%">
</p>

<br>

##### 2. 유클리드 거리

유클리드 거리는 각 문장을 벡터로 표현한 뒤, 두 벡터간의 직선 거리를 계산하여 단어들이 얼마나 떨어져 있는지를 측정하는 방식입니다. 직선 거리가 짧을 수록 더 유사도는 높게 평가됩니다.

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/7c862a5c-4a17-4683-b068-5e750853c348" align="center" width="48%">
</p>

<br>

#### 3. 자카드 유사도

마지막으로 자카드 유사도 방식에서는 두 집합이 얼마나 공통적인 원소를 가지는지를 토대로 유사도를 측정하며, 단순히 교집합 크기를 합집합 크기로 나눈 값을 기반으로 유사도를 계산합니다. 

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/021d165d-7822-462d-9cd1-0e3a66b6b230" align="center" width="30%">
</p>

<br>

##### 유사도 계산 방법 별 차이

각 측정방법에 따라 문서간 유사도를 비교한 결과는 다르게 나타날 수 있었습니다. 예를 들어 아래의 3 문장을 각기 다른 유사도 측정방식으로 비교한다고 가정해 보겠습니다:

  - 문장1: "나는 사과와 바나나를 좋아하지만, 포도는 싫어한다"
  - 문장2: "나는 사과와 바나나를 좋아한다"
  - 문장3: "나는 감자와 당근을 좋아한다"

<br>

위의 세 문장을 각기 다른 유사도 측정방식으로 비교하기 위해, 단어의 빈도수에 따른 벡터화를 진행한 결과는 다음과 같습니다:

| - | 나는 | 사과와 | 바나나를 | 좋아하지만 | 포도는 | 싫어한다 | 감자와 | 당근을 | 좋아한다 | 사과와 |
| - | - | - | - | - | - | - | - | - | - | - |
| "나는 사과와 바나나를 좋아하지만, 포도는 싫어한다" | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| "나는 사과와 바나나를 좋아한다" | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| "나는 감자와 당근을 좋아한다" | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |

<br>

위의 예시를 각각의 유사도 계산 방식에 따라 비교한 결과는 다음과 같습니다:

| - | 문장 1 & 2 | 문장 1 & 3 | 문장 2 & 3 |
| - | - | - | - |
| 코사인 유사도 | ~0.77 | ~0.18 | 0.23 |
| 유클리드 거리 | sqrt(3) | sqrt(6) | sqrt(5) |
| 자카드 유사도 | 0.5 | 0.125 | 0.167 |

<br>

가장 유사도가 높은 문장에 대해서는, 3가지의 유사도 측정방법 모두 문장 1과 2가 가장 유사하다고 판단하였습니다. 하지만 가장 덜 유사한 문장을 판단한 결과에 대해서는 각 방법별로 차이가 존재했습니다. 코사인 유사도 방식에서는 문장 1과 2를, 유클리드 거리와 자카드 유사도 방식에서는 문장 1와 3이 가장 덜 비슷하다고 판별되었습니다. 이렇듯 측정방식 별로 결과가 다를 수 있어 Galpy와 **가장 적합한 유사도 측정 방식을 선정**하여 적용하는 것이 중요했습니다.

각 유사도 별 장단점은 아래와 같이 정리됩니다:

| - | 코사인 유사도 | 유클리드 거리 | 자카드 유사도 |
| - | - | - | - |
| 장점 | 문서의 크기(길이)에 영향을 받지 않음, 희소 데이터에도 잘 작동하며, 고차원 데이터에 대해 계산이 효율적 | 두 벡터 간의 절대적인 거리를 측정하므로, 벡터의 크기가 중요한 경우에 사용하기 좋음 | 단어의 존재 유무만을 고려하므로, 특정 단어가 여러 번 등장하는 경우에도 잘 작동 |
| 단점 | 문장의 구조, 단어의 순서를 고려하지 않음 | 고차원 데이터에서는 성능이 떨어질 수 있으며, 문장의 길이가 서로 다른 경우 잘 작동하지 않을 수 있음 | 단어의 빈도수를 고려하지 않음. 두 문서가 동일한 단어를 가지고 있더라도, 그 단어들이 문서 내에서 얼마나 자주 등장하는지는 고려하지 않음 |

<br>

본 서비스를 사용하는 사용자의 특성을 고려할 때, 생성하는 책갈피의 길이가 다 다르고 나타나는 단어의 빈도수에 따라 관심도가 구분되어야 한다고 생각했습니다. 따라서 최종적으로는 **코사인 유사도** 방식을 사용하여 사용자들의 관심사 유사도를 측정하기로 결정하였습니다. 

<br>

### 관심사 유사도 계산하기
  
사용자가 생성한 해시태그 데이터에 **코사인 유사도 방식을 적용**하여 사용자간 관심사 유사도를 측정하는 로직은 다음과 같습니다: 
  [사용자간 관심사 유사도 연산 로직](https://github.com/CheckGalpy/galpy-server/blob/develop/tasks/updateSimilarity.js).

<br>

## 3. 로딩시간 단축하기

### 사전연산을 통해 로딩속도 개선하기

쿠팡이나 NETFLIX와 같이 사용자의 취향을 분석하여 다른 상품을 추천하는 알고리즘이 중요한 기업에서는, 사용자와 취향이 비슷한 **다른 사용자의 선택**을 해당 사용자에게 추천하는 방식을 도입하고 있습니다. 
  
이 방법을 벤치마킹 하여 Galpy에서는 사용자가 팔로우 하고 있지 않은 계정 중에서, **관심사 유사도가 가장 높은 계정 5개의 책갈피를 하나씩 추천** 하는 방식을 채택 했습니다. 똑같이 5개의 추천이 이루어 지더라도, 하나의 계정에서 5개의 책갈피를 추천하는 것보다 5개의 각기 다른 계정에서 책갈피를 하나씩 추천했을 때에 사용자에게 노출되는 계정의 수가 많아지기 때문에, 사용자들간의 교류를 더욱 활성화시킬 목적으로 해당 방법을 채택하였습니다.

가장 유사도가 높은 계정을 판별하기 위해서는 모든 사용자간의 유사도를 연산해야 했는데 사용자가 100명일 때와 1000명일 때의 빈도는 다음과 같았습니다:
  - 유저 100명: 유사도 연산 4,950번 
  - 유저 1000명: 유사도 연산 약 50만번

유저가 늘어남에 따라 연산해야하는 수가 기하급수적으로 늘어났으며, 사용자가 메인화면(대시보드)에서 책갈피를 추천받을 때마다 이러한 연산이 일어난다면 UX를 심각하게 해칠 수 있다고 판단하였습니다. 
  
이 문제를 해결하기 위하여 1일 1회, 트래픽이 가장 적을 것으로 예상되는 시간 (새벽 4시)에 사전 연산을 진행하기로 결정하였으며, `node-cron` 라이브러리를 사용하여 서버에서 사전연산을 진행하고 DB에 유사 유저 목록을 업데이트 하는 방식을 선택하였습니다.

```javascript
// updateSimilarity.js

function startCronJob() {
  cron.schedule("0 0 4 * * *", updateSimilarityScores);
  updateSimilarityScores();
}
```

<br>


## 4. 편의성과 보안

### 리액트 네이티브에서 토큰과 스토리지 사용하기

어플리케이션이 다시 실행될 때마다 매번 로그인을 해야하는 것은 사용자 경험을 크게 저해시킨다고 생각하였습니다. 이에 일반적으로 사용되는 토큰 인증방식을 사용하여 사용자의 로그인 상태를 유지하기로 결정하였습니다. 수명이 짧고 인증에 직접 사용되는 `Access Token`과, 비교적 긴 수명을 가지고 `Access Token`을 재발급하는 데 사용되는 `Refresh Token`을 사용하여 사용자 인증기능을 구현할 수 있었습니다.
 
토큰을 저장하기 위해 웹 환경의 `localStorage`와 비슷한 `React Native` 모바일 환경의 `AsyncStorage`를 가장 먼저 고려하였습니다. 하지만 `AsyncStorage`는 데이터를 암호화 하지 않고 저장하기 때문에 보안에 취약할 수 있어 토큰을 바로 저장하는 것이 보안상 좋지 않다는 결론을 내렸습니다. 대안으로서, `iOS`의 `Keychain`과 `Android`의 `Keystore`를 사용하여 데이터를 암호화하는 라이브러리 `Expo Secure Store`를 사용하여 `accessToken`과 `refreshToken`을 안전하게 저장하고 사용자 인증을 구현할 수 있었습니다.

<br>
 
# UX 개선하기

## 1. 검색 경험 개선하기

### 검색 키워드 하이라이팅

검색 기능이 사용자에게 제공하는 가장 큰 가치는, 키워드와 관련된 내용을 **한눈에 볼 수 있다는 점**입니다. 따라서 키워드와 매칭하는 단어가 본문이나 해시태그에 존재할 때, 해당 단어를 하이라이트 해주어 쉽게 파악할 수 있으면 좋겠다고 생각했습니다.

하지만 아래와 같이 검색하고자 하는 키워드가 썸네일이 아닌 사각지대에 위치할 경우, 검색은 되지만 하이라이트 된 부분이 썸네일에서 누락되어 보여지지 않는다는 문제가 있었습니다.

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/802613b2-25ae-406d-ad56-c31fae86b652"  width="40%">
</p>

<br> 

해당 문제를 해결하고, 사용자가 본문 내에서 검색 키워드의 앞뒤 맥락을 용이하게 파악할 수 있도록 검색어와 매칭되는 책갈피는 자동으로 펼쳐지도록 구현하였습니다. 결론적으로 검색 키워드가 어느 부분에서 매칭되는지 한눈에 볼 수 있게 되었습니다.

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/a3214433-67bd-47c6-b3d8-35f684e8182d">
</p>

### 키워드 매칭하기

사용자가 마주하는 책갈피는 내가 생성한 책갈피와 팔로잉 하는 계정의 책갈피, 이렇게 두 종류로 구분 되어집니다. 그리고 각 구분에 따라, 제공해야 하는 **기능에 차이**가 발생하였습니다.

먼저 사용자가 직접 생성한 책갈피는 "**사용자가 이미 읽었던 내용**"이라는 특징이 있습니다. 따라서 책갈피 목록을 구성할 때, 너무 많은 양의 본문을 썸네일로 보여주기 보단, 내용을 빠르게 보고 떠올릴 수 있을 정도의 양이 더 적합하다고 판단하였습니다. 이에 **썸네일**에서 보여주는 텍스트의 양을 **5줄**로 한정 하였습니다.

또한 사용자가 직접 생성한 책갈피는 언제든지 본문과 해시태그를 자유롭게 편집할 수 있어야 했습니다. 그러기 위해선 별도의 **편집모드**를 구성하고, 태핑 모션을 감지하여 해당 책갈피의 편집모드로 이동하는 것이 UX를 가장 향상시킬 수 있는 방법이라고 판단하였습니다. 이에 따라 구성된 사용자 생성 책갈피의 UI는 아래와 같습니다:

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/a6006696-ac9a-4115-81c6-45010dd772a9">
</p>
 
<br>

반면 팔로잉 계정의 책갈피를 열람하는 경우, 해당 책갈피는 사용자가 읽어보지 않은 책의 페이지일 수 있었습니다. 사용자는 이 목록을 빠르게 훓으면서 관심가는 책갈피를 즐겨찾기에 저장할 수 있는데, 이 때 **처음보는 내용**을 부분만 읽고 파악하기에는 썸네일의 길이가 짧다는 판단되었습니다. 따라서 썸네일에서 보여주는 텍스트의 양을 **7줄로 상향 조정**하였습니다.

편집과 관리가 필요한 **사용자 생성 책갈피**와는 다르게, 팔로잉 계정 책갈피의 경우 열람하는 사용자가 편집을 할 수 없어야 했습니다. 따라서 본문의 전체 내용을 확인하기 위해 편집모드와 같은 별도의 화면으로 이동시키기 보단, 목록화면에서 **드롭다운 토글**을 통해 바로 본문을 확인할 수 있는 UI를 구성하는 것이 UX를 향상시키는 방법이라고 생각하였습니다.

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/75c3fab5-e3cb-435f-9cfc-c0b06bfb967a">&nbsp;
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/6e1e29f3-b813-42c0-8b1d-16ae11ff2cb1">
</p>

<br> 

### 검색 키워드 하이라이팅

<br> 

## 2. 목록 열람 경험 개선하기
  
### 효율적인 썸네일 구조 제작

### 삭제하기와 팔로잉 인터랙션의 차이

책갈피 삭제 기능과 팔로잉 기능 모두 한번의 터치로 한가지의 결정을 내린다는 공통점이 있습니다.

삭제 기능을 구현하며, 사용자가 **실수**로 책갈피를 지울 수 있다고 판단하였습니다. 이때 어떤 책갈피가 삭제되었는지 알기 어렵고 구도 어렵다는 점을 감안하여 삭제 버튼의 **터치 범위를 축소**하고, 사용자가 정말 삭제를 원하는지 **확인 메시지**를 한번 더 확인받도록 구현하였습니다.

반면에 팔로잉 기능의 경우, 터치로 결정을 내린다는 점은 동일하지만 리스크에 차이가 있었습니다. 실수로 언팔로우 버튼을 눌러도 다시 사용자를 검색하여 추가하기만 하면 되었습니다. 또한 결정적으로, 관심 책갈피를 쇼핑하기 위해 사용자 목록을 빠르게 스킴하는 경우 일일이 확인메시지를 받는다면 UX를 크게 손상시킬 거라 판단하였습니다. 이에 팔로잉/언팔로잉 기능은, **해당 화면을 벗어나지만 않는다면 언제든지 상태를 토글**할 수 있도록 구현하였습니다.

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/12c6ea42-7645-4b51-b88c-9322af329ece">&nbsp;
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/7f7e76ef-ea9c-4eb7-937e-2bcff97ec1c8">
</p>

<br>




# Tech Stack

### Front-End

- React Native (Expo)
- react-navigation
- react-redux
- ESLint

### Back-End
- Node.js
- Express
- MongoDB
- ESLint

### API
- Google Vision API

<br />

# Timeline

**기획기간 (6일) - 2023.04.03. ~ 2023.04.08.**

- 목업 디자인
- DB스키마 생성
- 칸반 생성

**개발기간 (18일) - 2023.04.09. ~ 2023.04.26.**

- 기능구현

<br>

# Remarks

사용자의 입장에서 시작하여, 디자이너의 시각에 이입을 하고, 개발자의 눈으로 제품을 개발할 수 있는 기회였습니다. 

제품은 하나이지만 시각에 따라 각 입장별로 중점은 다를 수 있다는 것을 직접 느끼고 밀도있게 경험할 수 있었습니다.

