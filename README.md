# **Galpy**

<br>

<p align="center">
  <img width=300 src="https://github.com/CheckGalpy/galpy-client/blob/develop/assets/images/logo.png" />
</p>

<br>

Galpy는 간단한 촬영으로 **책갈피**를 생성하고 관리할 수 있게 해주는 모바일 어플리케이션입니다.

**팔로잉** 기능을 통해 자신의 책갈피를 공유하거나 관심 계정의 책갈피를 열람할 수 있으며, **추천 알고리즘**을 통해 유사한 관심사를 가진 사용자의 책갈피를 추천 받고, 취향에 맞는 책갈피를 **즐겨찾기**에 추가할 수 있습니다.

> [Galpy 시연 영상](https://youtu.be/cUFZ1A8MCoU?t=5132) 

> [서버 레포지토리](https://github.com/CheckGalpy/galpy-server)

<br>

# Table of Contents

- [Preview](#preview)
- [Motivation](#motivation)
- [Challenges](#challenges)
  - [1. 촬영으로 책갈피 생성하기](#1-촬영으로-책갈피-하기)
    - [지저분하게 추출된 텍스트, 간편하게 가공할 순 없을까?](#지저분하게-추출된-텍스트-간편하게-가공할-순-없을까)
    - [연사모드: 여러 이미지를 묶어 하나의 책갈피를 생성하기](#연사모드-여러-이미지를-묶어-하나의-책갈피를-생성하기)
  - [2. 책갈피 추천 알고리즘](#2-책갈피-추천-알고리즘)
    - [책갈피 추천은 어떤 근거로 이루어질까?](#책갈피-추천은-어떤-근거로-이루어질까)
    - [관심사 유사도 계산하기](#관심사-유사도-계산하기)
    - [추천 알고리즘 구현](#추천-알고리즘-구현)
    - [사전연산을 통해 로딩시간 단축하기](#사전연산을-통해-로딩시간-단축하기)
  - [3. React Native에서 사용자 인증 적용하기](#3-React-Native에서-사용자-인증-적용하기)
    - [로그인 없이 어떻게 사용자를 인증할 수 있을까?](#로그인-없이-어떻게-사용자를-인증할-수-있을까)
    - [React Native 환경에서 token 저장하기](#React-Native-환경에서-token-저장하기)
  - [4. UX 개선하기](#4-UX-개선하기)
    - [검색 키워드 하이라이팅](#검색-키워드-하이라이팅)
    - [효율적인 썸네일 구조 제작](#효율적인-썸네일-구조-제작)
- [Tech stack](#tech-stack)
- [Timeline](#timeline)
- [Remarks](#remarks)

<br>

# Preview

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/5051b956-dfbe-45d9-9206-37f5805a5d13" align="center" width="19%">&nbsp;
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/44b18e62-ed3a-4741-beef-a6f7ba291e90" align="center" width="19%">&nbsp;
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/f5b2d654-8c5d-44da-a1e6-d35e8c5fc8c4" align="center" width="19%">&nbsp;
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/0bdf91a8-a0e9-4a3c-a607-c4b66466b493" align="center" width="19%">&nbsp;
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/8e246ab2-b809-4128-a088-38ababb2c4a2" align="center" width="19%">
</p>

<details>
  
  <summary>기능 목록</summary>
  
  ### 대시보드 스크린
  1. 책갈피 추천
  2. 해시태그, 팔로잉, 즐겨찾기 정보 현황 디스플레이
  
  ### 책갈피 스크린
  1. 나의 책갈피 디스플레이
  2. 수집된 책갈피 디스플레이 <br> 
  3. 책갈피 검색/하이라이팅 <br> 
  4. 책갈피 정렬 <br> 
  5. 책갈피/해시태그 편집/삭제 <br> 
  6. 책갈피 오토포매팅</td>
  
  ### 갈피추가 스크린
  1. 책갈피 생성 <br> 
  2. 책갈피 연사촬영</td>

  ### 팔로잉 스크린
  1. 팔로잉 목록 디스플레이 <br> 
  2. 친구 찾기 <br> 
  3. 팔로잉 목록 검색 <br> 
  4. 팔로잉 목록 정렬 <br> 
  5. 팔로우/언팔로우</td>

  ### 설정 스크린
  1. 로그아웃
  
</details>

<br>

# Motivation

책을 읽다가 인상깊은 글귀를 발견했을 때면 드는, '**이 책갈피는 저장해 두었다가 나중에 다시 읽고 싶다'**'라는 생각에서 Galpy는 출발하게 되었습니다.

처음에는 해당 글귀의 위치를 표시하기 위해 책 페이지의 모서리를 접거나 본문에 밑줄을 긋는 등의 방법을 사용하였습니다. 하지만 책 원본이 훼손된다는 단점이 있었고, 이를 극복하기 위한 방법으로 처음엔 메모앱/노션등의 기록도구로 저장하고자 하는 글귀를 일일이 타이핑치고 분류해 왔습니다. 하지만 책을 읽을 때마다 항상 컴퓨터가 필요하다는 점과, 기록과 읽기를 병행해야 한다는 점은 여전히 큰 불편함으로 다가왔습니다.

<p align="center">
    <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/941d7bd4-bbc9-4abd-81aa-583d85796f0f">
</p>

<div align="center">
  <sub><기존에 책갈피를 저장하던 방법></sub>
</div>
  
<br>

<br>

이에 원본을 훼손하거나 일일이 기록하지 않아도 글귀를 저장할 수 있으며, 검색기능을 통해 연관된 주제의 책갈피들을 편리하게 열람할 수 있는 서비스가 있으면 좋겠다는 스스로의 니즈가 있었습니다. 그리고 이러한 니즈를 충족시키기 위해서는 카메라로 글귀를 촬영하여 텍스트를 추출하고, 추출된 텍스트를 책갈피의 형태로 생성하여 관리해주는 서비스가 필요하다고 판단하였습니다. 그렇게 OCR (광학문자열인식) API를 이용한 모바일 어플리케이션, Galpy를 기획하고 개발하게 되었습니다.

<br>

# Challenges

## 1. 촬영으로 책갈피 생성하기

### 지저분하게 추출된 텍스트, 간편하게 가공할 순 없을까?

먼저, 사용자가 간편하게 책갈피를 생성할 수 있도록 `React Native`와 `Google Vision API`를 이용하여 촬영된 책의 이미지에서 텍스트를 추출하는 기능을 구현하였습니다. `OCR API`의 한국어 텍스트 인식률에 대한 우려와 달리, 한글과 영어의 문자열 모두 높은 정확도로 추출할 수 있었습니다.

하지만 촬영되는 책 페이지의 레이아웃은 각각 다르고, 포함되어진 문장간의 줄바꿈이 일관되지 않다는 문제점이 있었습니다. 책갈피를 생성하기 위해선 추출된 텍스트를 **가독성 좋은 블록 형태**로 저장해야 하는데, 이를 위해선 사용자가 일일이 줄을 오가며 **줄바꿈**을 되돌려야 한다는 불편함이 있었습니다.

<p align="center">
    <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/e5c07d94-59b9-43a0-8776-2c3e7698c936">
</p>

<div align="center">
  <sub><일관되지 못한 줄바꿈으로 인해 가독성이 해쳐진 모습></sub>
</div>
  
<br>

<br>

위의 문제를 해결하기 위해 `정규표현식`을 사용하여 추출된 텍스트 덩어리를 분리하고, 줄바꿈을 제거한 뒤 다시 연결할 수 있는 기능을 구현하였습니다. 해당기능을 트리거하는 방법은 다음과 같이 크게 3가지가 있었습니다:
|-| 자동 포매팅 | 버튼 터치시 동작 | 터치 모션 감지 |
|---|---|---|---|
| 장점 | 간편 | 상황에 따라 포맷팅 유무 선택가능 | 상황에 따라 포맷팅 유무 선택불가 <br> 모바일 기기만의 특성 적용가능 |
| 단점 | 포매팅 선택권 없음 | UI의 복잡도 상승| - |
  
<br>

매 촬영마다 해당기능이 자동으로 활성화되는 `자동 포매팅`의 경우, 간편하지만 상황에 따라 사용자가 포맷팅을 원치 않을 수 있다고 판단하였습니다. 버튼을 추가하는 경우 사용자에게 선택권을 줄 수 있다는 장점이 있지만, UI가 복잡해지며 UX를 해칠 확률이 높아질 것이라고 생각하였습니다. 이에 사용자에게 선택권을 부여하면서도 별도의 UI컴포넌트의 추가를 필요로 하지 않는 터치 모션을 사용하여 포맷팅 기능을 트리거 하기로 결정하였습니다.
  
다양한 터치 모션중에서, 텍스트열을 압축시키는 듯한 모습과 가장 유사한 제스쳐인 `핀치모션`의 감지를 통해 '**두 손가락을 오므리면 줄바꿈을 제거해주는 기능**'을 최종적으로 구현하기로 결정하였습니다. 또한 사용자의 핀치모션을 감지하기 위해서 `react-native-gesture-handler` 라이브러리의 `PinchGestureHandler` 컴포넌트를 사용하였으며, 실수로 포매팅이 되는 것을 방지하면서도 모션의 인식이 용이할 수 있도록 모션 인식 민감도를 설정하였습니다.

<p align="center">
    <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/a5e4f56a-3cd1-4532-b875-d5cd0cc8fd07">
</p>
  
<div align="center">
  <sub><핀치모션으로 포매팅을 적용하는 모습></sub>
</div>

<br>

### 연사모드: 여러 이미지를 묶어 하나의 책갈피를 생성하기

책갈피를 생성하며 유저가 겪는 또다른 어려움은, 촬영하고 싶은 글귀가 책의 좌우 **두 페이지에 걸쳐**있을 때 발생 하였습니다. 기존의 기능만으로는 분단된 글귀를 각각 별개의 책갈피로 생성하거나, 하나의 글귀만 촬영하여 나머지 텍스트를 직접 추가해야 하는 불편함이 있었습니다. 

<p align="center">
    <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/69c4c876-b340-4266-965e-b0a6cb29160e7">
</p>

<div align="center">
  <sub><타겟 문자열의 분단 케이스 예시></sub>
</div>
  
<br>
  
이러한 사용자의 불편함을 해결하기 위해, 촬영을 여러번 진행하더라도 각 이미지에서 추출된 텍스트를 **하나의 덩어리로 연결**하여 책갈피를 생성할 수 있는 기능인 `연속스캔` 기능의 개발이 필요하다고 판단하였습니다. 
  
기존에는 촬영을 통해 추출한 텍스트를 상태에 저장하여 관리하였는데, 해당 상태는 Scan.js 하나의 컴포넌트에서만 사용되었기 때문에 useState를 통해 로컬에서 관리하고 있었습니다.
  
| Screen Name | Scan.js | ScanEdit.js | BookmarkDetail.js |
|---|---|---|---|
| 화면 예시 |<img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/e4b0db5f-6171-4f87-8ff1-3db559f63422">|<img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/7695eb71-cfa3-420d-a03e-f07d778e1259">|<img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/3988d42a-c805-498f-9335-fe4671b5eb9e">|
| 상태정보 | N/A | 추출 텍스트를 `local state`에 저장 | N/A |

<div align="center">
  <sub><연속스캔기능 추가 전 useEffect를 이용한 상태관리 플로우></sub>
</div>
  
<br>
  
<br>
  
`연속스캔` 기능을 구현하기 위해서는, 먼저 `ScanEdit.js` 컴포넌트가 렌더링된 화면에서 페이지의 촬영을 진행한 후, 텍스트를 추출하여 상태에 저장하고, 다시 촬영 대기화면인 `Scan.js` 컴포넌트 렌더링 하면으로 이동하여 텍스트를 추출하는 과정을 반복해야 했습니다. 그리고 이 과정에서 새롭게 추출된 텍스트는, 이전의 상태에 저장되어 있던 텍스트 위에 덧붙여서 저장되어야 하는 구조였습니다.
  
결국 `navigation`간 스크린이 이동되어지며 화면이 다시 렌더링 되어도 상태를 보존해야 하는 필요성이 생김에 따라, 기존 `useState`를 통해 로컬에서 관리되던 상태를 `redux`를 통해 전역에서 관리하는 방법으로 변경하기로 결정하였습니다.
  
<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/8cf05109-e11b-40fb-98c1-99d9e3f3e49b">
</p>
  
<div align="center">
  <sub><연속스캔기능 추가 후 redux를 이용한 상태관리 플로우></sub>
</div>

<br>
  
<br>

## 2. 책갈피 추천 알고리즘

### 책갈피 추천은 어떤 근거로 이루어질까?
  
본 프로젝트에서 구현된 기능들의 목적은 크게 2종류로 구분되어집니다:
  
  1. 직접 책갈피를 생성 / 관리
  2. 타인의 책갈피를 수집 / 열람
  
사용자는 자신이 읽은 책의 페이지를 책갈피로 생성하여 관리하는 것 외에도, `친구찾기` 기능을 통해 타 유저를 `팔로우`하고, 관심계정의 책갈피를 수집함으로서 접근가능한 책갈피의 양을 확장시킬 수 있습니다. 
  
  하지만 `친구찾기` 기능은 지인의 ID를 알 아야만 적용할 수 있었으며, 팔로잉을 하여 지인의 책갈피를 열람한다고 해도 대부분 자신의 관심사와 다른 내용의 책갈피라는 한계가 있었습니다. 이에 따라, 사용자간의 취향이 얼마나 비슷한지를 수치화하고, 이를 토대로 사용자의 취향과 유사한 계정과 책갈피를 추천하는 기능을 구현하기로 결정하였습니다.
  
  책갈피를 생성할 때 사용자들은 `해시태그`를 함께 생성하게 되는데, 이 해시태그 데이터를 수합하고 분석하여 문서 유사도 계산방법을 적용하는 것으로 방향을 설정하였습니다. 
  
  문서간 유사도를 비교하는데 주로 사용되는 방법은 아래와 같이 크게 3가지가 있었습니다:
  
<br>

##### 1. 코사인 유사도

코사인 유사도는 문장 내의 단어들이 얼마나 유사한 방향을 가리키는지 측정합니다. 이 방법에서는 각 문장을 벡터로 표현하고, 두 벡터 간의 각도를 기반으로 유사도를 계산합니다. 

<p align="center">
  <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2a8c50526e2cc7aa837477be87eff1ea703f9dec" align="center" width="40%">&nbsp;
  <img src="https://wikidocs.net/images/page/24603/%EC%BD%94%EC%82%AC%EC%9D%B8%EC%9C%A0%EC%82%AC%EB%8F%84.PNG" align="center" width="40%">
</p>

<br>

##### 2. 유클리드 거리

유클리드 거리는 각 문장을 벡터로 표현한 뒤, 두 벡터간의 직선 거리를 계산하여 단어들이 얼마나 떨어져 있는지를 측정하는 방식입니다. 직선 거리가 짧을 수록 더 유사도는 높게 평가됩니다.

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/7c862a5c-4a17-4683-b068-5e750853c348" align="center" width="48%">
</p>

<br>

#### 3. 자카드 유사도

마지막으로 자카드 유사도 방식에서는 두 집합이 얼마나 공통적인 원소를 가지는지를 토대로 유사도를 측정하며, 단순히 교집합 크기를 합집합 크기로 나눈 값을 기반으로 유사도를 계산합니다. 

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/021d165d-7822-462d-9cd1-0e3a66b6b230" align="center" width="30%">
</p>

<br>

##### 유사도 계산 방법 별 차이

각 측정방법에 따라 문서간 유사도를 비교한 결과는 다르게 나타날 수 있었습니다. 예를 들어 아래의 3 문장을 각기 다른 유사도 측정방식으로 비교한다고 가정해 보겠습니다:

  - 문장1: "나는 사과와 바나나를 좋아하지만, 포도는 싫어한다"
  - 문장2: "나는 사과와 바나나를 좋아한다"
  - 문장3: "나는 감자와 당근을 좋아한다"

<br>

위의 세 문장을 각기 다른 유사도 측정방식으로 비교하기 위해, 단어의 빈도수에 따른 벡터화를 진행한 결과는 다음과 같습니다:

| - | 나는 | 사과와 | 바나나를 | 좋아하지만 | 포도는 | 싫어한다 | 감자와 | 당근을 | 좋아한다 | 사과와 |
| - | - | - | - | - | - | - | - | - | - | - |
| "나는 사과와 바나나를 좋아하지만, 포도는 싫어한다" | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| "나는 사과와 바나나를 좋아한다" | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| "나는 감자와 당근을 좋아한다" | 1 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |

<br>

위의 예시를 각각의 유사도 계산 방식에 따라 비교한 결과는 다음과 같습니다:

| - | 문장 1 & 2 | 문장 1 & 3 | 문장 2 & 3 |
| - | - | - | - |
| 코사인 유사도 | ~0.77 | ~0.18 | 0.23 |
| 유클리드 거리 | sqrt(3) | sqrt(6) | sqrt(5) |
| 자카드 유사도 | 0.5 | 0.125 | 0.167 |

<br>

  3가지 유사도 측정방법에서 모두 문장 1과 2가 가장 유사하다는 것으로 계산되었습니다. 하지만 가장 덜 유사한 문장의 판별에 있어서는 각 방법별로 차이가 존재했습니다. 
  
  코사인 유사도 방식에서는 문장 1과 2가 가장 덜 유사하다고 계산된 반면, 유클리드 거리와 자카드 유사도 방식에서는 문장 1와 3이 가장 덜 비슷하다고 판별되었습니다. 이렇듯 적용하는 측정방식에 따라 결과가 다를 수 있어, **Galpy와 가장 적합한 유사도 측정 방식을 선정**하여 적용하는 것이 중요했습니다.

유사도 별 장단점은 아래와 같이 정리됩니다:

| - | 코사인 유사도 | 유클리드 거리 | 자카드 유사도 |
| - | - | - | - |
| 장점 | - 문서의 크기(길이)에 영향을 받지 않음 <br> - 희소 데이터에도 적용 가능 <br> - 고차원 데이터에 대해 계산이 효율적 | - 벡터의 크기가 중요한 경우에 사용하기 좋음 | - 단어의 존재 유무만을 고려 <br> - 특정 단어의 빈도가 높아도 잘 작동 |
| 단점 | - 문장의 구조, 단어의 순서를 고려 X | - 고차원 데이터에서는 성능이 떨어질 수 있음 <br> - 문장의 길이가 다른 경우 부정확할 수 있음 | - 단어의 등장 빈도를 고려하지 않음 |

<br>

  사용자가 생성하는 책갈피의 특정을 고려할 때, **문장간의 길이**가 다르고, **단어의 빈도수**에 따라 해당 단어가 사용자의 관심사에 미치는 영향이 크다고 생각하였습니다. 따라서 `코사인 유사도` 방식을 사용하여 사용자들의 `해시태그`를 비교하고, 이를 토대로 사용자의 `관심사 유사도`를 측정하기로 최종 결정하였습니다. 

<br>

### 관심사 유사도 계산하기
  
사용자가 생성한 해시태그 데이터에 **코사인 유사도 방식을 적용**하여 사용자간 관심사 유사도를 측정하는 로직은 다음과 같습니다: <br>
  [사용자간 관심사 유사도 연산 로직](https://github.com/CheckGalpy/galpy-server/blob/develop/tasks/updateSimilarity.js)

<br>
  
### 추천 알고리즘 구현
  
쿠팡이나 NETFLIX와 같이 사용자의 취향에 따라 상품을 추천하는 서비스에서는, 사용자와 취향이 비슷한 **다른 사용자의 선택**을 해당 사용자에게 추천하는 방식을 도입하고 있었습니다. 예를 들어, 사용자와 샴푸 구매 패턴이 비슷한 사용자가 구매한 린스를 추천하는 등의 방식입니다.
 
Galpy에서는 이를 벤치마킹하여 책갈피 추천 알고리즘을 구현하고, 추천 목록을 `대시보드`에 적용하여 사용자가 마주하는 가장 첫 화면에 추천 책갈피를 배치하였습니다.
  
<p align="center">
    <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/29662e60-00e9-44e8-8a8b-52f6f9717581" align="center" width="19%">
</p>
  
<div align="center">
  <sub><carousal 형식으로 대시보드에서 책갈피를 추천하는 기능></sub>
</div>

<br>
  
책갈피는 대시보드의 상단에서 `carousal` 형식으로 사용자에게 추천되었으며, UX를 고려할 때 5개 이상의 책갈피는 사용자에게 피로감을 유발할 수 있다고 판단하였습니다. 이렇게 5개의 책갈피를 선정하여 추천할 때에는 다음과 같은 사항을 고려하였습니다:
    
<p align="center">
    <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/196b6a85-0879-433c-aaa8-61c86cfd1694" align="center" width="80%">
</p>
  
<br>
  
  먼저 추천하는 책갈피를 모두 하나의 계정에서 불러올지 아니면 각각 다른 계정에서 불러올지를 고민하였습니다. 만약 가장 높은 유사도를 가진 계정에서 모든 책갈피를 추천 받는다면, 해당 계정에 대한 **의존도가 너무 높아**질 수 있다고 판단하여, 5개의 추천 모두 각각 별개의 계정에서 불러오기로 결정하였습니다.
  
  또한 가장 관심사가 유사한 계정 5개를 선별할 때, 사용자가 이미 팔로잉하고 있는 계정은 제외하기로 결정하였습니다. 이미 팔로잉 하는 계정의 책갈피는 사용자가 팔로잉 탭에서 **직접** 열람할 수 있어, 이를 다시 **중복 추천**하는 것은 사용자 경험을 저해시킬 수 있다고 판단하였기 때문입니다.
  
  추천이 이루어질 계정을 결정한 뒤에는, 해당 계정에서 유사도가 높은 책갈피와 가장 최신 책갈피 중 어느 책갈피를 추천할 지에 대한 고민이 있었습니다. 가장 유사한 책갈피를 추천하는 경우 사용자의 현 관심상태를 반영할 수 있으나, 사용자가 관심가질 만한 새로운 주제의 책갈피를 추천하는 것이 어렵다고 판단하였습니다. 따라서 최종적으로 이미 팔로잉 중인 계정을 제외한 계정에서 각각 가장 최근에 생성된 책갈피 하나씩을 추천하는 방식으로 추천 알고리즘을 구현하였습니다.
  
[책갈피 추천 알고리즘 함수 링크](https://github.com/CheckGalpy/galpy-client/blob/10a472a41fda7ee7058a525eb85c176a10bd51a4/screens/Dashboard/Dashboard.js#L49C3-L127)
  
<br>

### 사전연산을 통해 로딩시간 단축하기

가장 유사도가 높은 계정을 판별하기 위해서는 모든 사용자간의 유사도를 연산해야 했는데 사용자가 100명일 때와 1000명일 때의 빈도는 다음과 같았습니다:
  - 유저 100명: 유사도 연산 4,950번 
  - 유저 1000명: 유사도 연산 약 50만번

유저가 늘어남에 따라 연산해야하는 수가 기하급수적으로 늘어났으며, 사용자가 메인화면(대시보드)에서 책갈피를 추천받을 때마다 이러한 연산이 일어난다면 UX를 심각하게 해칠 수 있다고 판단하였습니다. 
  
이 문제를 해결하기 위하여 1일 1회, 트래픽이 가장 적을 것으로 예상되는 시간 (새벽 4시)에 사전 연산을 진행하기로 결정하였으며, `node-cron` 라이브러리를 사용하여 서버에서 사전연산을 진행하고 DB에 유사 유저 목록을 업데이트 하는 방식을 선택하였습니다.

```javascript
// updateSimilarity.js

function startCronJob() {
  cron.schedule("0 0 4 * * *", updateSimilarityScores);
  updateSimilarityScores();
}
```

<br>

## 3. React Native에서 사용자 인증 적용하기

### 로그인 없이 어떻게 사용자를 인증할 수 있을까?

어플리케이션이 다시 실행될 때마다 매번 로그인을 해야하는 것은 사용자의 편의성을 크게 저해시킨다고 생각하였습니다. 따라서 재방문시 로그인 절차를 거치지 않더라도 사용자를 인증해줄 수 있는 기능을 구현하기로 결정하였습니다. 
  
  먼저 사용자의 식별정보를 `payload`로 사용하여 인코딩하는 `JWT (JSON Web Token)` 방식을 적용하여 `access token`을 생성하였으며, 이를 통해 재 로그인 없이 사용자를 인증할 수 있었습니다. 
  
하지만 `JWT` 방식은 암호화가 아닌 인코딩 방식으로서, `access token`이 노출된다면 누구나 이 정보를 디코딩하여 사용자의 정보가 노출되어질 수 있다는 문제점이 있었습니다. 이 문제를 해결하기 위해 `access token`의 유효기간을 짧게 설정하여 보안을 강화하는 방법을 적용하였으나, 해당 시간이 만료되면 사용자가 다시 로그인을 해야한다는 점은 여전히 불편함으로 남아 있었습니다.
  
보안 수준을 유지하면서도 사용자의 편의성을 향상시키기 위해서는 `access token`의 만료시간을 유지하면서 로그인 없이 `access token`을 발급할 수 있는 방법이 필요했습니다. 이에 `access token`의 만료기간을 검사하고 자동으로 재발급을 진행해주는 `refresh token`의 생성 로직을 아래와 같이 추가로 구현하였습니다. <br>
  [access/refresh Token 발급 로직 링크](https://github.com/CheckGalpy/galpy-server/blob/develop/routes/api/auth/authController.js)
  
  <br>
  
  Access Token과 refresh token의 목적, 유효기간 및 사용 시점은 다음과 같습니다.
  
|-| Access Token | Refresh Token |
|---|---|---|
| 목적 | 사용자를 인증에 사용 | 액세스 토큰이 만료시 새 액세스 토큰 발급에 사용 |
| 설정 유효기간 | 1시간 | 14일 |
| 사용되는 시점 | 클라이언트가 서버에 요청을 보낼 때마다 사용 | 액세스 토큰이 만료되었을 때만 사용 |
  
<div align="center">
  <sub><accessToken과 refreshToken의 비교></sub>
</div>

<br>
  
  ### React Native 환경에서 token 저장하기
     
  일반적인 웹 환경이라면 `access token`과 `refresh token`을 `cookie`나 `local storage`에 저장하는 방법을 고려할 수 있었습니다. 하지만 해당 저장소는 `react native` 환경에서는 지원되지 않았으며, `local storage``와 유사한 `async storage`의 사용을 가장 먼저 고려해 볼 수 있었습니다.
  
  `async storage`는 `React Native`에서 제공하는 저장소로, `key-value` 형식의 데이터를 디스크에 저장하게 해주어 앱이 종료되더라도 저장된 데이터를 보존시킬 수 있다는 특징이 있습니다. 하지만 데이터를 암호화하지 않고 저장한다는 특징 또한 가지고 있어, 좀 더 안전하게 token을 저장할 수 있는 방법이 없는지 고민하게 되었습니다.
  
  대안으로서, `iOS`의 `Keychain`과 `Android`의 `Keystore`를 사용하여 데이터를 암호화하는 라이브러리인 `Expo Secure Store`를 사용하여 `accessToken`과 `refreshToken`을 암호화하고 보안을 강화하면서도 사용자 편의성을 개선시킨 인증을 구현할 수 있었습니다. <br>
[token의 secure storage 저장 로직 링크](https://github.com/CheckGalpy/galpy-client/blob/develop/utils/requestTokenAndStore.js)
  
<br>
 
## 4. UX 개선하기

### 검색 키워드 하이라이팅

검색 기능이 사용자에게 제공하는 가장 큰 가치는, 키워드와 관련된 내용을 **한눈에 볼 수 있다는 점**입니다. 따라서 키워드와 매칭하는 단어가 본문이나 해시태그에 존재할 때, 해당 단어를 하이라이트 해주어 쉽게 파악할 수 있으면 좋겠다고 생각했습니다.

하지만 아래와 같이 검색하고자 하는 키워드가 썸네일이 아닌 사각지대에 위치할 경우, 검색은 되지만 하이라이트 된 부분이 썸네일에서 누락되어 보여지지 않는다는 문제가 있었습니다.

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/802613b2-25ae-406d-ad56-c31fae86b652"  width="40%">
</p>

<br> 

해당 문제를 해결하고, 사용자가 본문 내에서 검색 키워드의 앞뒤 맥락을 용이하게 파악할 수 있도록 검색어와 매칭되는 책갈피는 자동으로 펼쳐지도록 구현하였습니다. 결론적으로 검색 키워드가 어느 부분에서 매칭되는지 한눈에 볼 수 있게 되었습니다.

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/a3214433-67bd-47c6-b3d8-35f684e8182d">
</p>

### 키워드 매칭하기

사용자가 마주하는 책갈피는 내가 생성한 책갈피와 팔로잉 하는 계정의 책갈피, 이렇게 두 종류로 구분 되어집니다. 그리고 각 구분에 따라, 제공해야 하는 **기능에 차이**가 발생하였습니다.

먼저 사용자가 직접 생성한 책갈피는 "**사용자가 이미 읽었던 내용**"이라는 특징이 있습니다. 따라서 책갈피 목록을 구성할 때, 너무 많은 양의 본문을 썸네일로 보여주기 보단, 내용을 빠르게 보고 떠올릴 수 있을 정도의 양이 더 적합하다고 판단하였습니다. 이에 **썸네일**에서 보여주는 텍스트의 양을 **5줄**로 한정 하였습니다.

또한 사용자가 직접 생성한 책갈피는 언제든지 본문과 해시태그를 자유롭게 편집할 수 있어야 했습니다. 그러기 위해선 별도의 **편집모드**를 구성하고, 태핑 모션을 감지하여 해당 책갈피의 편집모드로 이동하는 것이 UX를 가장 향상시킬 수 있는 방법이라고 판단하였습니다. 이에 따라 구성된 사용자 생성 책갈피의 UI는 아래와 같습니다:

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/a6006696-ac9a-4115-81c6-45010dd772a9">
</p>
 
<br>

반면 팔로잉 계정의 책갈피를 열람하는 경우, 해당 책갈피는 사용자가 읽어보지 않은 책의 페이지일 수 있었습니다. 사용자는 이 목록을 빠르게 훓으면서 관심가는 책갈피를 즐겨찾기에 저장할 수 있는데, 이 때 **처음보는 내용**을 부분만 읽고 파악하기에는 썸네일의 길이가 짧다는 판단되었습니다. 따라서 썸네일에서 보여주는 텍스트의 양을 **7줄로 상향 조정**하였습니다.

편집과 관리가 필요한 **사용자 생성 책갈피**와는 다르게, 팔로잉 계정 책갈피의 경우 열람하는 사용자가 편집을 할 수 없어야 했습니다. 따라서 본문의 전체 내용을 확인하기 위해 편집모드와 같은 별도의 화면으로 이동시키기 보단, 목록화면에서 **드롭다운 토글**을 통해 바로 본문을 확인할 수 있는 UI를 구성하는 것이 UX를 향상시키는 방법이라고 생각하였습니다.

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/75c3fab5-e3cb-435f-9cfc-c0b06bfb967a">&nbsp;
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/6e1e29f3-b813-42c0-8b1d-16ae11ff2cb1">
</p>

<br> 
  
### 효율적인 썸네일 구조 제작

책갈피 삭제 기능과 팔로잉 기능 모두 한번의 터치로 한가지의 결정을 내린다는 공통점이 있습니다.

삭제 기능을 구현하며, 사용자가 **실수**로 책갈피를 지울 수 있다고 판단하였습니다. 이때 어떤 책갈피가 삭제되었는지 알기 어렵고 구도 어렵다는 점을 감안하여 삭제 버튼의 **터치 범위를 축소**하고, 사용자가 정말 삭제를 원하는지 **확인 메시지**를 한번 더 확인받도록 구현하였습니다.

반면에 팔로잉 기능의 경우, 터치로 결정을 내린다는 점은 동일하지만 리스크에 차이가 있었습니다. 실수로 언팔로우 버튼을 눌러도 다시 사용자를 검색하여 추가하기만 하면 되었습니다. 또한 결정적으로, 관심 책갈피를 쇼핑하기 위해 사용자 목록을 빠르게 스킴하는 경우 일일이 확인메시지를 받는다면 UX를 크게 손상시킬 거라 판단하였습니다. 이에 팔로잉/언팔로잉 기능은, **해당 화면을 벗어나지만 않는다면 언제든지 상태를 토글**할 수 있도록 구현하였습니다.

<p align="center">
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/12c6ea42-7645-4b51-b88c-9322af329ece">&nbsp;
  <img src="https://github.com/CheckGalpy/galpy-client/assets/105766632/7f7e76ef-ea9c-4eb7-937e-2bcff97ec1c8">
</p>

<br>

# Tech Stack

### Front-End

- React Native (Expo)
- react-navigation
- react-redux
- ESLint

### Back-End
- Node.js
- Express
- MongoDB
- ESLint

### API
- Google Vision API

<br />

# Timeline

**기획기간 (6일) - 2023.04.03. ~ 2023.04.08.**

- 목업 디자인
- DB스키마 생성
- 칸반 생성

**개발기간 (18일) - 2023.04.09. ~ 2023.04.26.**

- 기능구현

<br>

# Remarks

사용자의 입장에서 시작하여, 디자이너의 시각에 이입을 하고, 개발자의 눈으로 제품을 개발할 수 있는 기회였습니다. 

제품은 하나이지만 시각에 따라 각 입장별로 중점은 다를 수 있다는 것을 직접 느끼고 밀도있게 경험할 수 있었습니다.

